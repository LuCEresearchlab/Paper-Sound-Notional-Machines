\section{Analyzing Existing Notional Machines}
\label{chr:RevealingInconsistencies}

So far we have seen
how we can design sound \nms{} by
constructing \ensuremath{\Varid{f}_{\Conid{NM}}} using \ensuremath{\Varid{f}_{\Conid{PL}}} and
functions that convert between \ensuremath{\Conid{A}_{\Conid{PL}}} and \ensuremath{\Conid{A}_{\Conid{NM}}}.
%
Now we will analyze existing \nms{},
using their informal description to construct all components of the commutative diagram.
In particular, here,
we have a description
of \ensuremath{\Varid{f}_{\Conid{NM}}} entirely in terms of \ensuremath{\Conid{A}_{\Conid{NM}}}.
%
We then use property-based testing, using the soundness condition as a property,
to uncover unsoundnesses
and suggest improvements that eliminate them.
%
Table~\ref{tab:examples-fixing-nms}
shows
the notional machines
we use in this section
as well as
the corresponding programming language
and aspect of the semantics of the programming language
that the notional machine focuses on.

\begin{table}[]
    \centering
    \begin{tabular}{|r||l|l|l|}
        \hline
        \textbf{Section}            & \textbf{Notional Machine}           & \textbf{Programming Language}    & \textbf{Focus}      \\ \hline\hline
        \ref{sec:AlligatorEggs} & \nmName{Alligator} & \plName{UntypedLambda} & Evaluation \\ \hline
        \ref{sec:ListAsStack}  & \nmName{ListAsStack}           & -  & Data Structure (List) \\ \hline
        \ref{sec:ArrayAsParkingSpots} & \nmName{ArrayAsParkingSpots}   & \plName{Java}  & Evaluation (Arrays) \\ \hline
        % \ref{sec:Reduct} & \nmName{Reduct} & \plName{UntypedLambda} & step\\\hline
    \end{tabular}
    \caption{Notional machines, programming languages, and aspects of focus
    used in Section~\ref{chr:RevealingInconsistencies}.}
    \label{tab:examples-fixing-nms}
\end{table}


\input{sections/AlligatorNM}

\input{sections/ListAsStackNM}

\input{sections/ArrayAsParkingSpotsNM}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Conclusion}

%In this chapter,
%we have seen
%how we can
%analyze existing notional machines
%with respect to their soundness
%and, as a result,
%find inconsistencies and improve them.
%%
%We also discussed the challenges of designing a concrete representation for a notional machine.

%The analyses in this chapter
%were made simpler by our use of \plName{UntypedLambda} as
%the programming language under the focus of the notional machines.
%%
%In contrast,
%in the next chapter,
%we will use essentially the same technique to analyze and improve a notional machine that is focused on Java,
%a much larger language.

